<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <title>Язык программирования "C#"</title>
  <link rel="stylesheet" href="css\style.css" type="text/css" />
</head>
<body background="kod.png">
<div id="basic">
  <header >
   <!-- Верхнее меню сайта -->
    <div id="top-menu">
        <div class="bg-1">
            <ul>
           <li><a href="index.html"><b>Вступление</b></a></li>
           <li><a href="2.html" ><b>Первое знакомство</b></a></li>
            <li><a href="3.html"><b>Классы и типы</b></a></li>
            <li><a href="5.html" ><b>Свяжитесь с нами</b></a></li>
            <li><a href="6.html"><b>Практические работы</b></a></li>
            
            </ul>
        </div>
        </div>
        </header> 
<!-- Основной текст-->
<style>
   a {text-decoration: none;} 
  </style>
<script> 
    document.onmousedown = function (e) {
        e = e || window.event;
        var b = (e.which ? (e.which < 2) : (e.button < 2));
        if (!b)return false;
    };
    document.oncontextmenu = function (e) {
        return false
    };

    function preventSelection(e) {
        var preventSelection = false;

        function addHandler (e, event, handler) {
            if (e.attachEvent) e.attachEvent ('on' + event, handler);
            else if (e.addEventListener) e.addEventListener (event, handler, false);
        }

        function removeSelection () {
            if(window.getSelection) {
                window.getSelection() .removeAllRanges();
            }
            else if (document.selection && document.selection.clear)
                document.selection.clear();
        }
        addHandler (e, 'mousemove', function() {
            if (preventSelection) removeSelection();
        });
        addHandler(e, 'mousedown', function (e) {
            e = e || window.event;
            var sender = e.target || e.srcElement;
            preventSelection = !sender.tagName.match (/INPUT|TEXTAREA/i);
        }); 
        function killCtrlA (e) {
            e = e || window.e
            var sender = e.target || srcElement;
            if (sender.tagName.match(/INPUT|TEXTAREA/i)) return;
            var key = e.keyCode || e.which;
            if ((e.ctrlKey && key == 'U'.charCodeAt(0)) ||  (e.ctrlKey && key == 'A'.charCodeAt(0)) || (e.ctrlKey && key =='S'.charCodeAt(0)))
        {
    removeSelection();
    if (e.preventDefault) e.preventDefault();
    else e.returnValue = false;
}
}
addHandler(e, 'keydown', killCtrlA);
addHandler(e, 'keyup', killCtrlA);
}
preventSelection(document);
</script>

<script type="text/javascript">
  function animateText(id, text, i) {
    document.getElementById(id).innerHTML = text.substring(0, i);
    i++;
    setTimeout("animateText('" + id + "','" + text + "'," + i + ")", 100);
  }
</script>
<big>
    <h1><p align="center">
<body  onload = 'animateText("dynamic-text", "Основные области C#", 0);'>
    <span id = 'dynamic-text'></span>
</body>
</big></p></h1>
<big><div class="shrift">
<p><a href="#Делегаты и лямбда-выражения">Делегаты и лямбда-выражения</a></p>
<p><a href="#Атрибуты">Атрибуты</a></p>
<h2>Массивы</h2>
<p>Массив — это структура данных, содержащая ряд переменных, доступ к которым осуществляется через вычисляемые индексы. Все содержащиеся в массиве переменные, также называемые элементами массива, относятся к одному типу. Этот тип называется типом элемента массива.</p>
<p>Сами массивы имеют ссылочный тип, и объявление переменной массива только выделяет память для ссылки на экземпляр массива. Фактические экземпляры массива создаются динамически во время выполнения с помощью оператора new. Операция new задает длину нового экземпляра массива, которая затем фиксируется на время существования экземпляра. Элементы массива имеют индексы в диапазоне от 0 до Length - 1. Оператор new автоматически инициализирует все элементы массива значением по умолчанию. Например, для всех числовых типов устанавливается нулевое значение, а для всех ссылочных типов — значение null.</p>
<p>Следующий пример кода создает массив из int элементов, затем инициализирует этот массив и выводит содержимое массива.</p>
<p align="center"><img src="ОО1.png" wight="200" height="200" align="center"></p>
<p>В этом примере создается одномерный массив и выполняется работа с ней. Кроме этого, C# поддерживает многомерные массивы. Число измерений типа массива, также известное как ранг типа массива, равно 1 плюс количество запятых между квадратными скобками типа массива. Следующий пример кода поочередно создает одномерный, двухмерный и трехмерный массивы.</p>
<p align="center"><img src="ОО2.png" wight="100" height="100" align="center"></p>
<p>Массив a1 содержит 10 элементов, массив a2 — 50 элементов (10 × 5), и наконец a3 содержит 100 элементов (10 × 5 × 2). Элементы массива могут иметь любой тип, в том числе тип массива. Массив с элементами типа массива иногда называется массивом, так как длина массивов элементов не должна совпадать. Следующий пример создает массив массивов int.</p>
<p align="center"><img src="ОО3.png" wight="100" height="100" align="center"></p>
<p>В первой строке создается массив с тремя элементами, каждый из которых имеет тип int[] и начальное значение null. В следующих строках эти три элемента инициализируются ссылками на отдельные экземпляры массивов различной длины.</p>

<p>Оператор new позволяет указать начальные значения элементов массива с помощью инициализатора массива, который представляет собой список выражений, написанных между разделителями { и }. Следующий пример создает и инициализирует массив int[] с тремя элементами.</p>
<p align="center"><img src="ОО4.png" wight="50" height="50" align="center"></p>
<p>Длина массива определяется по числу выражений между скобками { и }. Инициализацию массива можно сократить, так как тип массива не обязательно объявлять повторно.</p>
<p align="center"><img src="ОО5.png" wight="50" height="50" align="center"></p>
<p>Оба приведенных выше примера дают результат, эквивалентный следующему коду:</p>
<p align="center"><img src="ОО6.png" wight="150" height="150" align="center"></p>
Оператор foreach можно использовать для перечисления элементов любой коллекции. Данный оператор использует IEnumerable"T" интерфейс , поэтому он может работать с любой коллекцией. Следующий код перечисляет массив из предыдущего примера:
<p align="center"><img src="ОО7.png" wight="150" height="150" align="center"></p>
<h2><p><a name="Делегаты и лямбда-выражения">Делегаты и лямбда-выражения</a></p></h2>
<p>Тип делегата представляет ссылки на методы с определенным списком параметров и типом возвращаемого значения. Делегаты позволяют использовать методы как сущности, сохраняя их в переменные и передавая в качестве параметров. Принцип работы делегатов близок к указателям функций из некоторых языков. В отличие от указателей функций, делегаты являются объектно-ориентированными и типобезопасными.</p>

<p>Следующий пример кода объявляет и использует тип делегата с именем Function.</p>
<p align="center"><img src="ОО8.png" wight="500" height="500" align="center"></p>
<p>Экземпляр Function с типом делегата может ссылаться на любой метод, который принимает аргумент double и возвращает значение double. Метод Apply применяет заданный Function к элементам double[] и возвращает double[] с результатами. В методе Main используется Apply для применения трех различных функций к double[].</p>

<p>Делегат может ссылаться либо на лямбда-выражение для создания анонимной функции (например (x) => x * x , в предыдущем примере), либо на статический метод (например Math.Sin , в предыдущем примере) или на метод экземпляра (например m.Multiply , в предыдущем примере). Делегат, который ссылается на метод экземпляра, также содержит ссылку на конкретный объект. Когда метод экземпляра вызывается через делегат, этот объект превращается в this в вызове.</p>

<p>Делегаты могут также создаваться с использованием анонимных функций или лямбда-выражений, то есть "встроенных методов", создаваемых при объявлении. Анонимные функции могут использовать локальные переменные соседних методов. В следующем примере не создается класс:</p>
<p align="center"><img src="ОО9.png" wight="50" height="50" align="center"></p>
<p>Делегат не имеет информации или ограничений в отношении того, к какому классу относится метод, на который он ссылается. Метод, на который указывает ссылка, должен иметь те же параметры и тип возвращаемого значения, что и делегат.</p>
<h2><p><a name="Атрибуты">Атрибуты</a></p></h2>
<p>Типы, члены и другие сущности в программе C# поддерживают модификаторы, которые управляют некоторыми аспектами их поведения. Например, доступность метода определяется с помощью модификаторов public, protected, internal и private. C# обобщает эту возможность, позволяя пользователям определять собственные типы декларативных сведений, назначать их для сущностей программы и извлекать во время выполнения. Программы указывают эти декларативные сведения путем определения и использования атрибутов.</p>

<p>Следующий пример кода объявляет атрибут HelpAttribute, который можно поместить в сущности программы для указания связей с соответствующей документацией.</p>
<p align="center"><img src="ОО10.png" wight="400" height="400" align="center"></p>
<p>Все классы атрибутов являются производными от базового класса Attribute, который предоставляется в библиотеке .NET. Чтобы задать атрибут, его имя и возможные аргументы указываются в квадратных скобках непосредственно перед объявлением соответствующей сущности.</p>
</big></div>
<div id="follow">
<a href="#"><p align="right"><img src="345.png"></p></a>
</div>
  </div>
  </body>
<div class="myclr"></div>
         
        <!-- Подвал -->
       <div id="podval"> 
            <div class="yellow"></div>
            <div class="p1"><p align="center"> denpashenko@mail.ru </div>
             <div class="p2"> Телефон +7 903-033-40-00
        </div>
        <div class="myclr"></div>
</html>