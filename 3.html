<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <title>Язык программирования "C#"</title>
  <link rel="stylesheet" href="css\style.css" type="text/css" />
</head>
<body background="kod.png">
<div id="basic">
    <header>
	 <!-- Верхнее меню сайта -->
    <div id="top-menu">
        <div class="bg-1">
            <ul>
          <li><a href="index.html"><b>Вступление</b></a></li>
            <li><a href="2.html"><b>Первое знакомство</b></a></li>
            <li><a href="4.html" ><b>Основные области C#</b></a></li>
            <li><a href="5.html" ><b>Свяжитесь с нами</b></a></li>
            <li><a href="6.html"><b>Практические работы</b></a></li>
            </ul>
        </div>
        </div>
        </header> 
       <!-- Основной текст-->
   <style>
   a { 
    text-decoration: none; 
   } 
  </style>
  <script> 
    document.onmousedown = function (e) {
        e = e || window.event;
        var b = (e.which ? (e.which < 2) : (e.button < 2));
        if (!b)return false;
    };
    document.oncontextmenu = function (e) {
        return false
    };

    function preventSelection(e) {
        var preventSelection = false;

        function addHandler (e, event, handler) {
            if (e.attachEvent) e.attachEvent ('on' + event, handler);
            else if (e.addEventListener) e.addEventListener (event, handler, false);
        }

        function removeSelection () {
            if(window.getSelection) {
                window.getSelection() .removeAllRanges();
            }
            else if (document.selection && document.selection.clear)
                document.selection.clear();
        }
        addHandler (e, 'mousemove', function() {
            if (preventSelection) removeSelection();
        });
        addHandler(e, 'mousedown', function (e) {
            e = e || window.event;
            var sender = e.target || e.srcElement;
            preventSelection = !sender.tagName.match (/INPUT|TEXTAREA/i);
        }); 
        function killCtrlA (e) {
            e = e || window.e
            var sender = e.target || srcElement;
            if (sender.tagName.match(/INPUT|TEXTAREA/i)) return;
            var key = e.keyCode || e.which;
            if ((e.ctrlKey && key == 'U'.charCodeAt(0)) ||  (e.ctrlKey && key == 'A'.charCodeAt(0)) || (e.ctrlKey && key =='S'.charCodeAt(0)))
        {
    removeSelection();
    if (e.preventDefault) e.preventDefault();
    else e.returnValue = false;
}
}
addHandler(e, 'keydown', killCtrlA);
addHandler(e, 'keyup', killCtrlA);
}
preventSelection(document);
</script>
  <script type="text/javascript">
  function animateText(id, text, i) {
    document.getElementById(id).innerHTML = text.substring(0, i);
    i++;
    setTimeout("animateText('" + id + "','" + text + "'," + i + ")", 100);
  }
</script>

<big>
    <h1><p align="center">
<body onload = 'animateText("dynamic-text", "Классы и типы", 0);'>
    <span id = 'dynamic-text'></span>
</body>
</big></p></h1>
  <big><div class="shrift">
  <p>C# является объектно-ориентированным языком, а значит поддерживает инкапсуляцию, наследование и полиморфизм. Класс наследуется непосредственно из одного родительского класса. Он может реализовывать любое число интерфейсов. Методы, которые переопределяют виртуальные методы родительского класса, должны содержать ключевое слово override, чтобы исключить случайное переопределение. В языке C# структура похожа на облегченный класс: это тип, распределяемый в стеке и реализующий интерфейсы, но не поддерживающий наследование. C# предоставляет record class типы и record struct , которые являются типами, целью которых в основном является хранение значений данных.</p>
  <p><a href="#Параметры типа">Параметры типа</a></p>
  <p><a href="#Базовые классы">Базовые классы</a></p>
  <p><a href="#Структуры">Структуры</a></p>
  <p><a href="#Перечисления">Перечисления</a></p>
  <p><a href="#Типы, допускающие значение NULL">Типы, допускающие значение NULL</a></p>
  <p><a href="#Кортежи">Кортежи</a></p>

<h2>Классы и объекты</h2>
<p>Классы являются самым важным типом в языке C#. Класс представляет собой структуру данных, которая объединяет в себе значения (поля) и действия (методы и другие функции-члены). Класс предоставляет определение для экземпляров класса, которые также именуются объектами. Классы поддерживают механизмы наследования и полиморфизма, которые позволяют создавать производные классы, расширяющие и уточняющие определения базовых классов.</p>

<p>Новые классы создаются с помощью объявлений классов. Объявление класса начинается с заголовка. Заголовок указывает:</p>
<div class="N"><li>Атрибуты и модификаторы класса</li></div>
<div class="G"><li>Имя класса</li></div>
<div class="B"><li>Базовый класс</li></div>
<div class="L"><li>Интерфейсы, реализуемые классом.</li></div>
<p>За заголовком между разделителями { и } следует тело класса, в котором последовательно объявляются все члены класса.</p>

<p>Следующий код является простым примером объявления класса с именем Point:</p>
  <p align="center"><img src="ТИЧ1.png" wight="200" height="200" align="center">
</p>

<p>Экземпляры классов создаются с помощью оператора new, который выделяет память для нового экземпляра, вызывает конструктор для инициализации этого экземпляра и возвращает ссылку на экземпляр. Следующие инструкции создают два объекта Point и сохраняют ссылки на эти объекты в двух переменных:</p>
<p align="center"><img src="ТИЧ2.png" wight="100" height="100" align="center">
</p>
<p>Занимаемая объектом память автоматически освобождается, когда объект становится недоступен. В C# нет ни необходимости, ни возможности освобождать память объектов явным образом.</p>
<h2><p><a name="Параметры типа">Параметры типа</a></p></h2>
<p>Универсальные классы определяют параметры типа. Параметры типа — это список имен параметров типа, заключенных в угловые скобки. Параметры типа следуют за именем класса. Параметры типа можно использовать в теле класса в определениях, описывающих члены класса. В следующем примере для класса Pair заданы параметры типа TFirst и TSecond:</p>
<p align="center"><img src="ТИЧ3.png" wight="200" height="200" align="center"></p>
<p>Тип класса, для которого объявлены параметры типа, называется универсальным типом класса. Типы структуры, интерфейса и делегата также могут быть универсальными. Если вы используете универсальный класс, необходимо указать аргумент типа для каждого параметра типа, вот так:</p>
<p align="center"><img src="ТИЧ4.png" wight="100" height="100" align="center"></p>
<p>Универсальный тип, для которого указаны аргументы типа, как Pair"int,string" в примере выше, называется сконструированным типом.</p>
<h2><p><a name="Базовые классы">Базовые классы</a></p></h2>
<p>В объявлении класса может быть указан базовый класс. Имя базового класса указывается после имени класса и параметров типа и отделяется от них двоеточием. Если спецификация базового класса не указана, класс наследуется от типа object. В следующем примере Point3D имеет базовый класс Point. В первом примере Point имеет базовый класс object:</p>
<p align="center"><img src="ТИЧ5.png" wight="200" height="200" align="center"></p>
<p>Класс наследует члены базового класса. Наследование означает, что класс неявно содержит почти все элементы базового класса. Класс не наследует экземпляры, статические конструкторы и метод завершения. Производный класс может добавлять новые члены к наследуемым, но не может удалить определение для наследуемого члена. В предыдущем примере Point3D наследует члены X и Y из Point, и каждый экземпляр Point3D содержит три свойства: X, Y и Z.</p>

<p>Используется неявное преобразование из типа класса к любому из типов соответствующего базового класса. Переменная типа класса может ссылаться как на экземпляр этого класса, так и на экземпляры любого производного класса. Например, если мы используем описанные выше объявления классов, то переменная типа Point может ссылаться на Point или Point3D:</p>
<p align="center"><img src="ТИЧ6.png" wight="100" height="100" align="center"></p>
<h2><p><a name="Структуры">Структуры</a></p></h2>
<p>Классы определяют типы, поддерживающие наследование и полиморфизм. Они позволяют создавать сложные расширения функциональности на основе иерархий производных классов. Напротив, типы структур — это более простые типы, основной целью которых является хранение значений данных. В структурах не может быть объявлен базовый тип; они неявно наследуются от System.ValueType. От типа struct не могут быть унаследованы другие типы struct. Они неявно запечатаны.</p>
<p align="center"><img src="ТИЧ7.png" wight="200" height="200" align="center"></p>
<h2><p><a name="Перечисления">Перечисления</a></p></h2>
<p>Тип Enum определяет набор значений констант. В следующем объявлении enum определяются константы, соответствующие различным корнеплодам:</p>
<p align="center"><img src="ТИЧ8.png" wight="200" height="200" align="center"></p>
<p>Также можно определить enum, которое будет использоваться в виде сочетания флагов. В следующем объявлении определяется набор флагов для четырех времен года. Можно применить любое сочетание времен года, в том числе значение All, включающее все времена года:</p>
<p align="center"><img src="ТИЧ9.png" wight="250" height="250" align="center"></p>
<h2><p><a name="Типы, допускающие значение NULL">Типы, допускающие значение NULL</a></p></h2>
<p>Переменные любого типа могут быть объявлены как не допускающий значения NULL или допускающий значение NULL. Переменная, допускающая значение NULL, может содержать дополнительное значение null, указывающее на отсутствие значения. Типы значений, допускающие значение NULL (структуры или перечисления), представляются System.Nullable"T". Ссылочные типы, не допускающие значение NULL и допускающие значение NULL, представляются базовым ссылочным типом. Различие представляется метаданными, которые считываются компилятором и некоторыми библиотеками. Если ссылки, допускающие значение NULL, разыменовываются без предварительной проверки значения на null, компилятор выдает предупреждения. Компилятор также выдает предупреждения, если ссылкам, не допускающим значение NULL, присваивается значение, которое может быть равно null. В следующем примере объявляется переменная целочисленного типа, допускающая значение NULL, и эта переменная инициализируется значением null. Затем ей присваивается значение 5. Он демонстрирует ту же концепцию со строкой, допуская значение NULL. Дополнительные сведения см. в статьях Типы значений, допускающие значение NULL и Ссылочные типы, допускающие значение NULL.</p>
<p align="center"><img src="ТИЧ10.png" wight="150" height="150" align="center"></p>
<h2><p><a name="Кортежи">Кортежи</a></p></h2>
<p>C# поддерживает кортежи, что обеспечивает краткий синтаксис для группировки нескольких элементов данных в упрощенной структуре данных. Кортежи являются альтернативой для структуры данных с несколькими элементами. Чтобы создать экземпляр кортежа, необходимо объявить типы и имена элементов между ( и ), как показано в следующем примере:</p>
<p align="center"><img src="ТИЧ11.png" wight="100" height="100" align="center"></p>
</big></div>
<div id="follow">
   <a href="#"><p align="right"><img src="345.png"></p></a>
</div>
</div>
  </body>
<div class="myclr"></div>
         
        <!-- Подвал -->
       <div id="podval"> 
            <div class="yellow"></div>
            <div class="p1"><p align="center"> denpashenko@mail.ru </div>
             <div class="p2"> Телефон +7 903-033-40-00
        </div>
        <div class="myclr"></div>
</html>